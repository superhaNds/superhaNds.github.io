---
layout: post
title: "2048 Functionally"
date: 2018-08-02
author: KMB
categories: General
tags: 2048, haskell
---

Implementing the popular mini-game [2048](https://gabrielecirulli.github.io/2048/) offers a great illustration of pure functional programming. The logic of the game can be written in Haskell in fewer than 50 lines and be more expressive and readable than any imperative solution can be.

First, let's define the basic types.

```haskell
-- | Four possible directions: up, down, left, and right.
data Direction = U | D | L | R

-- | Rows are lists of integer numbers.
type Row = [Int]

-- | A board is a list of rows.
type Board = [Row]
```

In this game, the player chooses the direction in which to shift the pieces. The cells are always powers of two and the starting pieces are twos. In our representation, a zero indicates an empty cell. 

Next, we define an empty square board. The game is played in a 4x4 board, but it is generalizable.

```haskell
-- | An empty square board of the given size n x n.
emptyBoard :: Int -> Board
emptyBoard n = map (const (map (const 0) [1 .. n])) [1 .. n]
```

The function merely maps the constant function zero and applies it to the lists at the row and at the board level.

Afterwards, the most important function, i.e., to move pieces to the left. Moving to the left is implemented first because it is natural to do so with functional lists. In fact, one only needs to implement the move to the left; the rest can be derived from this.

```haskell
-- | Moves the pieces left and merges equal numbers.
moveLeft :: Row -> Row
moveLeft r = r' ++ zeros
  where merge (n : m : ns) | n == m    = 2 * n : merge ns
                           | otherwise = n : merge (m : ns)
        merge x = x
        r'      = merge (filter (/= 0) r)
        zeros   = replicate (length r - length r') 0
```

In the moving process, we forget about empty cells since all pieces are moved to the left and if there are empty cells they are added at the end. In the merging process we compare the value of the two cells and upon matching we double the value and move on. Only two pieces can be merged with a given move.   

How can we move right given that we know how to move left? 

```haskell
-- | Moves the pieces right and merges equal numbers.
moveRight :: Row -> Row
moveRight = reverse . moveLeft . reverse     
```

Reverse the pieces, move them left and reverse back. It almost looks like an instruction in natural language.

Now that we have implementations of moving left and right, we can implement up and down as follows in the complete move function.

```haskell
-- | Moves the pieces of the board towards the specified direction and merges equal numbers.
move :: Board -> Direction -> Board
move board dir = case dir of 
  U -> transpose $ move (transpose board) L
  D -> transpose $ move (transpose board) R
  R -> map moveRight board
  L -> map moveLeft board
```

Moving the board is mapping the move function on each row. Moreover, moving up is moving left in the trasposed board whereas moving down is moving right in the transposed board again. All moving functions are derived from moving left!

Finally, we implement the rule of the game in a function that checks whether more moves are possible. So we have to check if a board is full and that no adjacent cells have the same power of two value.

```haskell
-- | True if the board has no empty cells.
boardFull :: Board -> Bool
boardFull = and . map (all (/= 0)) 

-- | True if there are no moves left in the given board.
noMovesLeft :: Board -> Bool
noMovesLeft b = boardFull b && noMergings b
  where noMergings b = and (map noMoveInRow b)
                        && and (map noMoveInRow (transpose b))
        noMoveInRow  = all (uncurry (/=)) . (zip <*> tail)
```

The I/O part of this game is left out since it is boring. To this end, one also has to generate a random location on the board after each move to place a new value of two which is always a tad trickier in pure functional languages. However, the pure computations of the game are clearly separated and quite concise.