---
layout: post
title: "Induction in Computer Science"
date: 2018-03-06
author: KMB
categories: General
tags: induction, structural-induction, mathematical-induction
---

Induction is, in my opinion, an underappreciated concept in computer science. It is quite powerful once we understand the generalization of induction that extends the principle to any inductively defined set. Mathematical induction, as it is taught  in mathematics and computer science curricula usually in discrete mathematics courses, focuses primarily on induction on the natural numbers. Induction is not restricted to the natural numbers; this idea has been generalized and is called **structural induction**.

Structural induction is a proof technique in logic that provides one with the means of proving a proposition for all elements in a set or structure. Let us first examine some inductively defined sets that give rise to an induction principle.

## Natural Numbers

We quickly go through the natural numbers, but this time we define the set more formally using induction. The set can be defined by two inference rules stating the following: that \\(0\\) is a natural number and that given some natural number \\(n\\), we can add \\(1\\) to get the next number. Using judgements, we write this as follows.

$$
\frac{}{0 \in \mathbb{N}} \quad \frac{n \in \mathbb{N}}{n + 1 \in \mathbb{N}}
$$

This can also be seen as a recursive data type; in Haskell, this set can be defined as an algebraic data type.

```haskell
data Nat = Z | S Nat
```

The induction principle for natural numbers is the following (we quantify over predicates here too), so it's expressed in second order logic.

$$
(\forall \, P \, . P(0) \land (\forall \, n \in \mathbb{N} \, . \, P(n) \to P(n + 1))) \to (\forall \, n \in \mathbb{N}  \, . \, P(n))
$$

Naturally, all properties are not valid for some numbers, for example, the base case could start for any natural number and proceed from there. An example proof that is not valid for \\(0\\). Our predicate is the following: \\(P(n) : 6 \mid n^3 + 3n^2 + 2n\\) and we want to show this for any natural number greater than zero. We prove the two cases, base and step.

*Base case*: for \\(n = 1\\)

$$ 
\begin{align}
	P(1) : 6 \mid 1 + 3 + 2 \to 6 \mid 6
\end{align}
$$

*Inductive step*: assume \\(P(k)\\) holds for some \\(k \in \mathbb{N}\\). We have to show that \\(6 \mid (k+1)^3 + 3(k+1)^2 + 2(k+1)\\). We have \\(P(k)\\) by hypothesis, so \\(k^3 + 3k^2 + 2k = 6m\\), for some natural number \\(m\\). Let's work on \\(P(k + 1)\\).

$$
\begin{equation}
	\begin{split}
		(k+1)^3 + 3(k+1)^2 + 2(k+1) &= 
		k^3+3k^2+3k+1+3k^2+6k+3+2k+2 \\
		&=(k^3+3k^2+2k) + 3k +3k^2 +6k + 6 \\
		&= 6m + 3k^2 + 9k +6\\
		&= 6m + 3(k^2+3k+2)\\
		&= 6m + 3(k+2)(k+1)\\
		&= 6m + 3(2b) \\
		&= 6(m+b)
	\end{split}
\end{equation}
$$

It was demonstrated that \\(P(k + 1)\\) also holds, i.e., the expression is divisible by \\(6\\), ergo by induction we have that \\(\forall \, n \in \mathbb{N}  \, . \, P(n)\\).

## Induction on Lists##

While induction on the natural numbers serves as good exercise, it is not of much interest to us as computer scientists. Data structures and data types that share an inductive definition are more relevant because they are often found in programming. A very basic inductive structure is a list. A list can be inductively defined with two constructors: the empty list and an extended list. Using Haskell notation:

```haskell
data List a = Nil | Cons a (List a)
```

A `List` can be either `Nil` (empty) or an element and the rest of the list (tail) `Cons a List`. The connection to the natural numbers should be evident. The princple of induction that follows for this structure is similar. In words, we say that to prove a property for lists, we have to prove it for `Nil` and if we assume it holds for the tail, we have to show that it holds for `Cons a tail`.

Before we use induction on lists, we define a few functions by recursion to use, namely, `append` and `length`.

```haskell
(++) :: List a -> List a -> List a
(++) Nil ys = ys
(++) (Cons x xs) ys  Cons x (xs ++ ys)

length :: List a -> Int
length Nil = 0
length (Cons _ xs) = 1 + length xs
```

Now to the property, we could show that `length (xs ++ ys) == length xs + length ys` for any `xs, ys`. This can be proven by list induction on `xs`

*Base case*: `xs = Nil`

```haskell
length (Nil ++ ys) 
== length ys
== 0 + length ys
== length Nil + length ys
```

*Inductive case*: `xs = Cons x xs`

```haskell
length (Cons x xs ++ ys)
== length (Cons x (xs ++ ys))
== 1 + length (xs ++ ys)
== 1 + (length xs + length ys)
== length (Cons x xs) + length ys
```

Proof by induction on lists works nicely. This technique can be used for trees, streams, vectors, and any inductively defined set. It does not matter how many constructors the set has, as long as it is well-founded.

Here are some more practice examples:

```haskell
(xs ++ ys) ++ zs == xs ++ (ys ++ zs)
length xs == length (reverse xs)
reverse (reverse xs) == xs
```

## Final remarks

Structural induction is used to prove fundamental safety properties about type systems for languages where terms are defined as a data type. In other words, properties are proven by induction on terms.

Induction is a techinque that is used by modern proof assistants. Proof assistants like Agda are high-level programming languages that allow users to express and prove properties about their programs. They rely on advanced type systems based on formal systems like type theory. In Agda, all data types are defined inductively from scratch to maintain mathematical purity. Afterwards, we notice that induction corresponds to recursion in programming, this means that an inductive proof is a recursive function with the inductive hypothesis being the recursive call with the smaller arguments.
