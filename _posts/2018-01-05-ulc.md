---
layout: post
title: Untyped Lambda Calculus - Scope safe 
---

There are numerous ways of implementing lambda calculus. The most
prominent way is to use de Bruijn indices instead of actual names
for variables since this technique is invariant to alpha equivalence
which is extremely useful.

An additional safety net is to keep track of the number of free variables
a given term may have. Thus, we want to see terms as a family of sets
indexed by natural number. That number will indicate the maximum number
of free variables it may contain. For example, a closed term would be
a term for each index. Naturall, a term doesn't need to have as many
free variables as the index suggests. This formulation is better
discussed in Benjamin Pierce's book [Types and Programming Languages](https://mitpress.mit.edu/books/types-and-programming-languages) in chapter 6 on nameless terms.

## Lambda Terms ##

Let's implement this notion in Agda since dependent types are
essential to have indexed data types. We start with the type
that represents lambda terms

```agda
data Tm (n : Nat) : Set where
  var  : (i : Fin n) → Tm n
  _·_  : (t u : Tm n) → Tm n
  ƛ    : (t : Tm (1 + n)) → Tm n
```

Here we see that `Tm` is indexed by a natural number. We say that
`Tm` is a family of types indexed by `n : Nat`. The variables
are indices, but here we must use a natural number less than `n`.
Thus, `Fin n` represents a natural number `i` such that `0 ≤ i < n`.
Infix notation for function application and we can see that for the
lambda abstraction, the term is extended since we have a binder for
a variable. This is an important notion to capture at the level
of the types. We may refer to these terms as well-scoped or scope safe.

Some examples, we construct the identity function and the `K` combinator.

```agda
I : Tm 0
I = ƛ (var zero)

K : Tm 0
K = ƛ (ƛ (var (suc zero)))
```

Both are closed terms, so the index of `Tm` could be any number from zero or
greater.

## Substitutions ##

We now want to implement substitutions for our lambda terms. We can use
vectors with dependent lengths that will assist in the correct typing
of our scope safe terms. First, we need substitutions of variables, i.e.,
renamings. Renamings are sequences of indices.

```agda
Ren : Nat → Nat → Set
Ren m n = Vec (Fin m) n

lift-ren : ∀ {m n} → Ren m n → Ren (1 + m) (1 + n)
lift-ren = λ ρ → zero ∷ map suc ρ

ren : ∀ {n m} → Tm n → Ren m n → Tm m
ren (var i) ρ = var (lookup i ρ)
ren (ƛ t)   ρ = ƛ (ren t (lift-ren ρ))
ren (t · u) ρ = (ren t ρ) · (ren u ρ)
```

Here, we rename free variables and we can see the interesting lambda case
where the renaming has to be extended and lifted. Thanks to the indices,
the type of the renaming is `Ren (1 + m) (1 + n)` and forgetting to lift
and extend is out of the question.

Next, we implement the parallel substitutions and the substitution
operation using weakening and renaming.

```agda
Subst : Nat → Nat → Set
Subst m n = Vec (Tm m) n

-- a sequence of fins {0, ..., n - 1}
up-ren : ∀ {n} → Ren (1 + n) n
up-ren = tabulate (suc)

weaken : ∀ {m} → Tm m → Tm (1 + m)
weaken t = ren t pR

weaken-subst : ∀ {m n} → Subst m n → Subst (1 + m) n
weaken-subst = map weaken

↑_ : ∀ {m n} → Subst m n → Subst (1 + m) (1 + n)
↑_ = (_, q) F.∘ weaken-subst
```

The `↑_` is lifting and extending a substitution. The connection between
renaming and substituting is clear. Variable weakening is applying adding
one to the index, whereas now we have binders. This leads to the final
substitution operation of terms.

```agda
_[_] : ∀ {m n} → Tm n → Subst m n → Tm m
var i    [ σ ] = lookup i σ
ƛ t      [ σ ] = ƛ (t [ ↑ σ ])
(t · u)  [ σ ] = t [ σ ] · u [ σ ]
```

Again, the lambda abstraction, we have to lift and extend the substitution which
requires the concept of renaming because we have to weaken the terms.
The types have a similar effect here in the sense that some erroneous implementations
of substitution are not type-checked.

Conclusively, this is a very nice way to implement lambda calculus if one has
dependent types are their disposal. The primary benefit is error prevention 
on things like weakening and lifting.

