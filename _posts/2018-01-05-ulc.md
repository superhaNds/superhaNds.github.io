---
layout: post
title: "Scope safe untyped lambda calculus"
date: 2018-01-05
author: KMB
categories: General
tags: untyped-lambda-calculus agda de-Bruijn-indices
---

There are numerous ways of implementing lambda calculus. The most prominent way is to use de Bruijn indices instead of actual names for variables since this technique is invariant to alpha equivalence which is extremely useful for implementation purposes.

An additional safety net is to keep track of the number of free variables a given term may have. Thus, we want to see terms as a family of sets indexed by natural number. That number will indicate the maximum number of free variables it may contain. For example, a closed term would be a term for each index. Naturally, a term doesn't need to have as many free variables as the index suggests. This formulation is better discussed in Benjamin Pierce's book [Types and Programming Languages](https://mitpress.mit.edu/books/types-and-programming-languages) in chapter 6 on nameless terms.

## Lambda Terms ##

Let's implement this notion in Agda since dependent types are essential to have indexed data types. We start with the type that represents lambda terms

```agda
data Tm (n : Nat) : Set where
  var  : (i : Fin n) → Tm n
  _·_  : (t u : Tm n) → Tm n
  ƛ    : (t : Tm (1 + n)) → Tm n
```

Here we see that `Tm` is indexed by a natural number. We say that `Tm` is a family of types indexed by `n : Nat`. The variables are indices, but here we must use a natural number less than `n`. Thus, `Fin n` represents a natural number `i` such that `0 ≤ i < n`. Infix notation for function application and we can see that for the lambda abstraction, the term is extended since we have a binder for a variable. This is an important notion to capture at the level of the types. We may refer to these terms as well-scoped or scope safe.

Some examples: we construct the identity function and the `K` combinator.

```agda
I : Tm 0
I = ƛ (var zero)

K : Tm 0
K = ƛ (ƛ (var (suc zero)))
```

Both are closed terms (don't contain free variables), so the index of `Tm` could be any number from zero and greater.

## Substitutions ##

We now want to implement parallel substitutions for our lambda terms. We can use vectors with dependent lengths that will assist in the correct typing of our scope safe terms. First, we need substitutions of variables, i.e., renamings. Renamings are sequences of indices.

```agda
Ren : Nat → Nat → Set
Ren m n = Vec (Fin m) n

lift-ren : ∀ {m n} → Ren m n → Ren (1 + m) (1 + n)
lift-ren = λ ρ → zero ∷ map suc ρ

ren : ∀ {n m} → Tm n → Ren m n → Tm m
ren (var i) ρ = var (lookup i ρ)
ren (ƛ t)   ρ = ƛ (ren t (lift-ren ρ))
ren (t · u) ρ = (ren t ρ) · (ren u ρ)
```

Here, we rename free variables and we can see the interesting lambda case where the renaming has to be extended and lifted. Thanks to the indices, the type of the renaming inside the lambda is `Ren (1 + m) (1 + n)`; so forgetting to lift and extend is out of the question because it would not pass type checking.

Next, we implement the parallel substitutions and the substitution operation using weakening and renaming.

```agda
Subst : Nat → Nat → Set
Subst m n = Vec (Tm m) n

-- a sequence of indices {0, ..., n - 1}
up-ren : ∀ {n} → Ren (1 + n) n
up-ren = tabulate (suc)

weaken : ∀ {m} → Tm m → Tm (1 + m)
weaken t = ren t up-ren

weaken-sub : ∀ {m n} → Subst m n → Subst (1 + m) n
weaken-sub = map weaken

↑_ : ∀ {m n} → Subst m n → Subst (1 + m) (1 + n)
↑_ = (_, q) F.∘ weaken-sub
```

The opeeration of `↑_` is lifting and extending a substitution. Lambda binds variables so this is unavoidable. Variable weakening is adding one to the index. This leads to the final substitution operation of terms.

```agda
_[_] : ∀ {m n} → Tm n → Subst m n → Tm m
var i    [ σ ] = lookup i σ
ƛ t      [ σ ] = ƛ (t [ ↑ σ ])
(t · u)  [ σ ] = t [ σ ] · u [ σ ]
```

As mentioned, for the lambda abstraction we have to lift and extend the substitution which requires the concept of renaming in order to weaken terms. The types have a similar effect here in the sense that some erroneous implementations of substitution are not type checked.

Conclusively, this is a very nice way to implement lambda calculus if one has dependent types at their disposal. The primary benefit is error prevention on things like weakening and lifting. This was untyped lambda calculus but we can use these terms for simple types and even dependent types if we wish.
